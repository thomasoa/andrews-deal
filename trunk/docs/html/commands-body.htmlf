<h1>Introduction</h1>
<table style="width: 100%" cellpadding=5><tr valign=top><td style="width: 65%">
This is meant to be a comprehensive list of commands in Deal which
are not native to Tcl.  If you want to learn Tcl, I will be providing
a set of pointers later.
<td style="width: 35%">
<div class='tcl'>
Text in blue is meant for Tcl afficianado
- reading this text without knowledge of Tcl might confuse more than
enlighten.
</div>
<br>
<div class='programmer'>
Text in green is meant for programmers
interested in finding code definitions.
</div>
</table>
<hr>

<a name="north"></a><a name="east"></a><a name="south"></a><a name="west"></a>
<a name="hand"></a>
<a name="shape"></a><a name="pattern"></a>
<h1>Hand commands: <code>north</code>, <code>east</code>, <code>south</code>, <code>west</code>, <code>hand</code></h1>
<table cellpadding=5 style="width: 100%">
<tr valign="top"><td style="width: 65%">
<h2>Usage</h2>
<pre class='example'>
east [ -void <em>string</em>] [ <em>suitname</em> ... ]
hand {<em>hand string</em>} [ -void <em>string</em>] [ <em>suitname</em> ... ]

south <em>subcommand</em> [ <em>... args ...</em> ]
hand {<em>hand string</em>} <em>subcommand</em> [ <em>... args ...</em> ]
</pre>
These are very strange commands - they really have too much stuffed
into them.  That's a historical anomoly which I'm reluctant to abandon.
<p>
With no subcommands, the routine is used for formatting the hand as
a string. For example, if south is:
<pre class='example'>
S: AJ5432
H: KT94
D: void
C: K93
</pre>
Then the results of various commands are:
<pre class='example'>
south                    =>    {AJ5432 KT94 {} K93}
south spades             =>    AJ5432
south hearts clubs       =>    {KT94 K93}
south -void -            =>    {AJ5432 KT94 - K93}
south -void --- diamonds =>    ---

set h {AK4 {} A95432 JT98}
hand $h                  =>    {AK4 {} A95432 JT98}
hand $h spades           =>    AK4
hand $h hearts clubs     =>    {{} JT98}
hand $h -void -          =>    {AK4 - A95432 JT98}
</pre>
The -void switch exists precisely for formatting the output.
<p>
The various subcommands will be treated in seperate sections.

The <code>hand</code> version of this command only works with some subcommands.
</td><td style="width: 35%">
<div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C code
<dt>Location:</dt>
<dd><code>tcl_deal.c</code>, function <code>tcl_hand_cmd</code>
</dl>
</div>
</td>
<tr valign=top><td style="width: 65%">
<h2>Subcommand: <code>shape</code></h2>
<h3>Usage</h3>
<pre class='example'>
north shape
hand {AJTxx Axx JTxx x} shape
</pre>
<h3>Summary</h3>
Returns a list of suit lengths, in standard order.
<p>
For example, the second command above would return the list:
<pre class='example'>
5 3 4 1
</pre>
<h2>Subcommand: <code>pattern</code></h2>
<h3>Usage</h3>
<pre class='example'>
north pattern
hand {AJ32 A5 JTxx xxx} pattern
</pre>
<h3>Summary</h3>
Returns a sorted list of the suit lengths, starting with the longest.
For example, the second command above would return the list:
<pre class='example'>
4 4 3 2
</pre>
<h2>Subcommand: <code>is</code></h2>
<h3>Usage</h3>
<pre class='example'>
south is {<em>handstring</em>}
</pre>
<h3>Summary</h3>
This command pre-places a specific 13 cards. For voids, you can use
the "<code>-</code>" character:
<pre class='example'>
south is {AJ32 KT932 - Q876}
</pre>
Calls to this subcommand must occur before dealing begins, outside the
"<code><a href="#main">main</a></code>" command.  
<p>
This subcommand calls the <a href="#stack_hand"><code>stack_hand</code> command.</a>
Inside the <code>main</code> code, the deal is already dealt.
<h2>Subcommand: <code>gets</code></h2>
<h3>Usage</h3>
<pre class='example'>
<em>handname</em> gets <em>card</em> [<em>card</em> ...]
</pre>
<h3>Summary</h3>
Puts a specific list of cards in the hand named.  As with the
"<code>is</code>" subcommand, this must be called before dealing
starts, outside the "<code><a href="#main">main</a></code>" command.
The card is specified in two characters, a rank character and a suit
character:
<pre class='example'>
AS KH JH 9D
</pre>
This routine dispatches its data to <a href="#stack_cards">the <code>stack_cards</code> command.</a>

<h2>Subcommand: <code>has</code></h2>
<h3>Usage</h3>
<pre class='example'>
<em>handname</em> has <em>card</em> [<em>card</em> ...]
hand {<em>string</em>} has <em>card</em> [...]
</pre>
<h3>Summary</h3>
This returns a count of the cards listed that occur in the hand named.
<pre class='example'>
% south
AJ54 JT54 43 654
% south has SA HK HJ HT
3
</pre>
</td><td style="width: 35%">&nbsp;</td></table>
<hr>
<h1>Control commands</h1>
<a name="accept"></a><a name="reject"></a>
<h2>Commands: <code>accept</code> and <code>reject</code></h2>
<table style="width: 100%" cellpadding=5><tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
accept [ [ if | unless ] <em>expr expr ...</em>]
reject [ [ if | unless ] <em>expr expr ...</em>]
</pre>
<h3>Summary</h3>
Without arguments, <code>accept</code> and <code>reject</code> are the
same as <span class='nobr'><code>return 1</code></span> and <span class='nobr'><code>return
0</code></span>, respectively.  
<p>
With arguments it's a little more obscure.
<pre class='example'>
accept if {$h>4}
</pre>
This returns 1 if the expression matches.  It is equivalent to:
<pre class='example'>
if {$h>4} { return 1 }
</pre>
The code:
<pre class='example'>
accept if {$h>4} {$s>4}
</pre>
Is logically equivalent to:
<pre class='example'>
if {$h>4 || $s>4} { return 1}
</pre>
That is, the values are accepted if either of the expressions
evaluates as true.
<p>
The <code>unless</code> option does the opposite:
<pre class='example'>
accept unless {$h>4} {$s>4}
</pre>
This is equivalent to:
<pre class='example'>
if {!($h>4) || !($s>4)} { return 1 }
</pre>
<p>
The means we return with a true value <em>unless</em> one of the expressions
is true.  If one of the values is true, we simply go on to the next line.
<p>
<h3>Examples</h3>
Virtually all of the examples included in the release contain an
instance of "accept" or "reject."

<td style="width: 35%;">
<div class='programmer'>
<b>For Programmers</b>
<dl>
<dt>Implementation:</dt>
    <dd>C code</dd>
<dt>Location:</dt>
    <dd>tcl_deal.c, procedure <code>tcl_deal_control</code>.</dd>
</dl>
<p>This construct is borrowed from the Perl programming language.
Originally, I added it to Deal 2.0 for performance reasons.  Those
reasons are obsolote with Tcl 8.x, but I like the mnemonic enough
to keep it, and removing it might confuse old users.</p>
</div>

<div class='tcl'>
<b>For Tcl Experts</b>
<p>There actually is one subtle and occasionally useful distinction
between <code>accept/reject</code> and the stated 
<pre class='example'>if {...} { return ... }</code></pre>
<p>version.  In reality:</p>
<pre class='example'>
accept if {$h>4} {$s>4}
</pre>
<p>is equivalent to:</p>
<pre class='example'>
if {$h>4||$s>4} { 
    return 1
}
expr 0
</pre>
This only matters when the command is the last
command in a procedure.  The two procedures:
<pre class='example'>
proc A {h s} {
    if {$h>4||$s>4} {
        return 1
    }	
}

proc B {h s} {
     accept if {$h>4} {$s>4}
}
</pre>
<p>are slightly different.</p>
<p>A call of <code>A 3 3</code> returns an empty string, while a call
of <code>B 3 3</code> returns 0. That can be useful, as you can see
here.</p>
</div>

</table>

<hr>
<a name="main"></a>
<h2>Command: <code>main</code></h2>
<table cellspacing=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
main {
   <em>block of code</em>
}
</pre>

<h3>Summary</h3>
This defines the primary block of code evaluated after <em>each</em>
deal is generated.  If the code <em>returns</em> true,
<b>Deal</b> will treat the deal as a "match" and call
<b>write_deal</b>. It will also increment its count of deals
found and exit if the limit is reached.
</td><td style="width: 35%">
<div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt><dd>C code</dd>
<dt>Location:</dt><dd>tcl_deal.c, procedure <code>tcl_deal_control</code>.
</dl>
</div>
</table>
<hr>

<a name="whogets"></a>
<h2>Command: <code>whogets</code></h2>
<table cellspacing=5 style="width: 100%">
<tr valign=top><td style="width:65%">
<h3>Usage</h3>
<pre class='example'>
whogets <em>cardname</em>
</pre>
This returns the name of the person holding the card <em>cardname</em>.
</td><td style="width: 35%">
<div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt><dd>C code</dd>
<dt>Location:</dt><dd>tcl_deal.c, procedure <code>tcl_deal_to_whom</code>.
</dl>
</div>
</table>
<hr>

<a name="deal_finished"></a>
<h2>Command: <code>deal_finished</code></h2>
<table cellspacing=5 style="width: 100%">
<tr valign=top><td style="width:65%">
<h3>Usage</h3>
<pre class='example'>
deal_finished {
   <em>block of code</em>
}
</pre>
This defines the code called at the completion of generating all deals.
This is code you would use to dump statistics, for example.
</td><td style="width: 35%">
<div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt><dd>C code</dd>
<dt>Location:</dt><dd>tcl_deal.c, procedure <code>tcl_after_set</code>.
</dl>
</div>
</table>
<hr>

<h1>Bridge Evaluators</h1>
<h2>Common interfaces</h2>
There are some standard interfaces to bridge evaluation functions.
<a name="handInterface"></a>

<h3>Hand Procedures</h3>
Any procedure defined entirely based on the values in one hand is considered
a <em>hand procedure</em>.  These procedures can be called in one of two
ways:
<pre class='example'>
Weak2Bid <em>handname</em>

Weak2Bid hand {AKQxxx xxx xxx x}
</pre>
The <em>handname</em> parameter can be one of
<code>north</code>, <code>south</code>, <code>east</code>, <code>west</code>.
<a href="#shapes">Shape procedures</a> and <a href="#holdingp">holding
procedures</a> fit the hand procedure calling method, along with other
options.
<hr>
<a name="shapes"></a>
<h3>Shape procedures</h3>
Any procedure defined on the shape of a hand can be called with one of
the following methods:
<pre class='example'>
balanced <em>handname</em>

balanced hand {AJ43 AKxx xxx K5}

balanced eval 4 3 4 2

balanced shape {4 3 4 2}
</pre>
This follows the <a href="#hand">hand procedure</a> outline with the
addition of the <code>eval</code> option.
<p>
<hr>
<a name="holdingp"></a>
<h3>Holding procedures</h3>
A holding procedure is a <a href="#handInterface">hand procedure</a>
which is evaluated on a bridge hand by evaluating each suit holding
one at a time, and then accumulate the results.  There are two
common ways of defining holding procedures,
<a href="#defvector"><code>defvector</code></a> and
<a href="#holdingProc"><code>holdingProc</code></a>.  
<p> This is an
abstraction of a very common bridge evaluation technique.  The most
commonly used holding functions are  <em>high card points</em>,
<em>losing trick count</em>, <em>controls</em>.  For example, when
counting the losers in the hand <code>AKxx Axx KQJxxx x</code>, we
find 1 loser in spades, 2 losers in hearts, 1 loser in diamonds,
and one loser in clubs.  We define the total losers to be the sum
across all suits, and get 5 losers, total.  <p> The interface lets
you evaluate the entire hand, or only selected suits in a hand, or
a specific list of holdings.

<pre class='example'>
hcp <em>handname</em> [ <em>suitname</em> ...  ]

hcp hand {AKJxxx K xxx xxx} [ <em>suitname</em> ...  ]

hcp holding AK43 [ ... ]
</pre>
In the first two cases, if no suits are named, all suits are evaluated, and
the results are accumulated.  In the case of the <code>holding</code> call,
the specific holdings passed in are evaluated.
<p>
Note, I've been saying "accumulated" rather than added.  In some cases,
you might have an accumulation method different from addition.  For example,
you might return the standard opening leads from a holding:
<pre class='example'>
    openingLead holding KQJ7    =>   K
    openingLead south           => {K} {7 2} {4} {J}
</pre>
Each suit would create a list of proposed leads, and the result would be
a list of lists of all standard leads from all holdings.  Here, the
accumulation is to simply make a list.
<hr>

<a name="balanced"></a>
<a name="semibalanced"></a>
<h2>Command: <code>balanced</code> and <code>semibalanced</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
balanced <em>handname</em>

balanced hand {<em>text hand</em>}

balanced eval <em>s</em> <em>h</em> <em>d</em> <em>c</em>
</pre>
<h3>Summary</h3>
These are both <a href="#shapes">shape procedures</a>.
<p>
<code>balanced</code> returns true if the hand is some 4333, 4432, or 5332
without a 5-card major.
<p>
<code>semibalanced</code> returns true if the hand has no singletons
 or voids, not six-card majors, and no seven-card minors.
<td style="width: 35%">
<div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd><code>Tcl</code> with <code>shapecond</code>
<dt>Location:</dt>
<dd><code>lib/features.tcl</code>
</dl>
<p>These use to be hard-coded in the C code, but it made more sense
to add them to the library code - the user can change the definitions
as he likes.</p>
</div>
</table>
<hr>

<a name="clubs"></a>
<a name="diamonds"></a>
<a name="hearts"></a>
<a name="spades"></a>
<h2>Commands: <code>clubs</code>, <code>diamonds</code>, <code>hearts</code>, <code>spades</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
     <code>spades</code> <em>handname</em>
     <code>spades</code> <code>hand</code> <code>{AKxx Axx AJxx Kx}</code>
</pre>
These implement the <a href="#hand">hand procedure</a> interface, and
return the suit lengths for the appropriate suit.
<td style="width: 35%">
<div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>
<dt>Location:</dt>
<dd><code>tcl_deal.c</code>, function <code>tcl_suit_count</code>
</dl>
<p>These could be <em>shape procedures</em> but for speed reasons, I've
left them this way.</p>
</div>
</table>
<hr>

<h1>Holding Evaluators</h1>
<a name="hcp"></a>
<h2>Command: <code>hcp</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
hcp <em>handname</em>
hcp <em>handname</em> <em>suitname</em> [<em>suitname</em> ...]
hcp hand {<em>s h d c</em>}
hcp hand {<em>s h d c</em>} <em>suitname</em> [<em>suitname</em> ...]
</pre>
This procedure computes standard high card points - ace is 4, king
is 3, queen is 2, jack is 1. The procedure implements the 
<a href="#holdingp">holding procedure</a> interface.
<td style="width: 35%"><div class='programmer'>
<b>For Programmers</b>
<dl>
<dt>Implementation:
<dd>C code
<dt>Location:
<dd>Built with additive.c, <code>tcl_create_additive</code>
      and deal.c, <code>count_hcp</code>
</dl>
</div>
</table>
<hr>

<a name="newLTC"></a>
<h2>Command: <code>newLTC</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
newLTC <em>handname</em>
newLTC <em>handname</em> <em>suitname</em> [<em>suitname</em> ...]
newLTC hand {<em>s h d c</em>}
newLTC hand {<em>s h d c</em>} <em>suitname</em> [<em>suitname</em> ...]
</pre>
<p>Rex Livingston provided this implementation of the <a href="http://en.wikipedia.org/wiki/Losing_trick_count#New_Losing_Trick_Count_.28NLTC.29">New  Losing Trick Count</a>, from a 2003 Bridge World article.</p>
<p>It looks to me much like a 3-2-1 count with some adjustments, and it seems odd to me that a stiff singleton would count as 1.5 losers.  Somehow, doesn't match the intuitive meaning of "loser" to me.
<td style="width: 35%">
<div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl code
<dt>Location:</dt>
<dd>lib/features.tcl</dd>
</dl>
</div>
</table>
<hr>

<a name="losers"></a>
<h2>Command: <code>losers</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
losers <em>handname</em>
losers <em>handname</em> <em>suitname</em> [<em>suitname</em> ...]
losers hand {<em>s h d c</em>}
losers hand {<em>s h d c</em>} <em>suitname</em> [<em>suitname</em> ...]
</pre>
This implements a <a href="#holdingp">holding procedure</a> which
computes the number of <em>half losers</em>.  This is for historical reasons -
the only holding functions allowed in past releases returned integer
values, but I wanted to have some refinements over raw losing trick count.
<td style="width: 35%">
<div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C code
<dt>Location:</dt>
<dd>Built with additive.c, <code>tcl_create_additive</code>
      and deal.c, <code>count_losers</code>
</dl>
It is probably better to reimplement in <code>Tcl</code> using
<a href="#holdingProc"><code>holdingProc</code></a>.
</div>
</table>
<hr>

<a name="binky"></a>
<h1>Binky Points Evaluators</h1>
<p>Binky Points are described in my <a href="<?php echo $bridgeFantasia;?>valuations/">hand evaluations articles.</a></p>
<p>Binky Points are designed so that sum of your partnership's Binky Point values comes as close as possible to the number of tricks that your partnership can make, double dummy.</p>
<a name="binky_suit"></a>
<a name="binky_nt"></a>
<h2>Commands: <code>binky::suit</code> and <code>binky::nt</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
source lib/binky.tcl
binky::nt <em>handname</em>
binky::nt hand {<em>s h d c</em>}
binky::suit <em>handname</em>
binky::suit hand {<em>s h d c</em>}
</pre>
These two functions are <a href="#handInterface">hand procedures</a> which
computes the Binky Point value for the hand.
<td style="width: 35%">
<div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl code
<dt>Location:</dt>
<dd><code>lib/binky.tcl</code> and <code>lib/binky-data.tcl</code>
</dl>
</div>
</table>

<h1>Bridge Logic and Utilities</h1>
<a name="lho"></a>
<a name="rho"></a>
<a name="partner"></a>
<h2>Commands: <code>lho</code>, <code>partner</code>, <code>rho</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign="top"><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
lho <em>handname</em>
rho <em>handname</em>
partner <em>handname</em>
</pre>
<h3>Summary</h3>
These routines accept one hand name and return another. For example,
"<code>lho north</code>" returns "<code>east</code>," and
"<code>partner east</code>"
returns "<code>west</code>."
<td style="width: 35%"><div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C code
<dt>Location:</dt>
<dd><code>tcl_deal.c</code>, function <code>tcl_other_hand</code>
</dl>
</div>
</table>
<hr>

<a name="holding"></a>
<h2>Commands: <code>holding</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
holding length AJxx           =>     4

holding contains AJ64 A6      =>     1 (true)
holding contains AJ64 A65     =>     0 (false)

holding encode AJ4            =>     4612  (binary: 1001000000100 )

holding decode 4612           =>     AJ4

holding matches AKxx  AK42    =>     1 (true)

holding disjoint AJ65 KT82    =>     1 (true)
holding disjoint A65  A32     =>     0 (false)

holding index AKJ4 0          =>     A
holding index AKJ4 1          =>     K
holding index AKJ4 3          =>     4
holding index AKJ4 -2         =>     J
holding index AKJ4 10         =>     ""
</pre>
<h3>Summary</h3>
<td style="width: 35%"><div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C code
<dt>Location:</dt>
<dd><code>holdings.c</code>, function <code>IDeal_HoldingCmd</code>
</dl>
</div>
</table>
<hr>

<a name="score"></a>
<h2>Command: <code>score</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
source lib/score.tcl
   ...
score <em>contract</em> <em>vulnerability</em> <em>tricks</em>
</pre>
<h3>Summary</h3>
This routine computes the standard duplicate bridge score for a contract
from the point of view of declarer, if declaring side takes the given number
of tricks.
<p>
The <em>contract</em> is passed as a list:
<pre class='example'>
2 spades

2 spades undoubled 

4 clubs doubled

6 notrump redoubled
</pre>
The <em>vulnerablity</em> is one of the words <code>vul</code> or
<code>nonvul</code>.
<p>
The <em>tricks</em> is the number of tricks taken by declarer.
<h3>Examples</h3>
<pre class='exaample'>
score {2 spades} nonvul 8           =>  110
score {2 spades doubled} nonvul 8   =>  470
score {2 spades redoubled} nonvul 8 =>  640
score {2 spades doubled} vul 8      =>  670
score {2 spades} nonvul 7           =>  -50
score {2 spades doubled} nonvul 7   =>  -100
score {2 spades doubled} vul 7      =>  -200
</pre>

<td style="width: 35%"><div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl
<dt>Location:</dt>
<dd><code>score.tcl</code>
</dl>
</div>
</table>
<hr>
<a name="dds"></a>
<h1>Double Dummy Solver</h1>
<p>Starting with Deal 3.1, I've included simple access to <a href='http://web.telia.com/~u07502278/'>Bo Haglund's double-dummy solver library.</a></p>
<a name="deal::tricks"></a>
<h2>Command: <code>deal::tricks</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deal::tricks <em>declarer</em> <em>denomination</em>
</pre>

<h3>Summary</h3>
<p><code>deal::tricks</code> returns the maximum number of tricks makable by <em>declarer</em> in the given <em>denomination</em>. 
<p><em>declarer</em> must be one of "north", "east", "south", or "west." By default, it is "south."</p>
<p><em>denomination</em> must be a suit name or "notrump."  The default value is "notrump."</p>
<p>By default, deal::tricks uses the <a href="#tricks"><code>tricks</code></a> function, which calls Bo Haglund's double-dummy solver.</p>
<p>However, if you include "lib/gib.tcl", <code>deal::tricks</code> will call the GIB double dummy solver.</p>
<p><code>deal::tricks</code> caches values, so multiple calls for the same deal with the same declarer and denomination will not result in multiple calls to the
double-dummy solver.</p>
<p>Bo Haglund's solver has a feature which makes it faster if the next double dummy solver call is in the same denomination as the previous call.  That means that
if you need all double-dummy values, you would want to write your code as:</p>
<pre class='example'>
   foreach denom {clubs diamonds hearts spades notrump} {
     foreach hand {north east south west} {
       set tricks [deal::tricks $hand $denom]
       ...
     }
   }
</pre>



<td style="width: 35%"><div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl</dd>
<dt>Location:</dt>
<dd><code>lib/features.tcl</code>
</dl>
</div>
</table>
<hr>



<a name="tricks"></a>
<h2>Command: tricks</h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
tricks [ <em>declarer</em> [ <em>denomination</em> [ <em>goal</em> ] ] ]
</pre>

<h3>Summary</h3>
<p>Unless you are using the <em>goal</em> parameter, you will probably want to use the <a href="#deal::tricks"><code>deal::tricks</code></a> command, since it has the
advantage of caching values.</p>
<p>When no goal is passed, "tricks" returns the maximum number of tricks makable by <em>declarer</em> in the given <em>denomination</em>. 
<p>If a (positive) goal number of tricks is set, "tricks" returns 1 if declarer can make that many tricks, and 0 if the defense can always hold declarer to fewer tricks.
<p><em>declarer</em> must be one of "north", "east", "south", or "west." By default, it is "south."</p>
<p><em>denomination</em> must be a suit name or "notrump."  The default value is "notrump."
<p><em>goal</em> must be an integer value, either -1 for "best play" or a value from 1 to 13 equal to the goal number of tricks for declarer. Default is -1.</p>

<td style="width: 35%"><div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C, C++</dd>
<dt>Location:</dt>
<dd><code>dds.cpp, tcl_dds.c</code>
</dl>
</div>
</table>
<hr>

<a name="ddscmd"></a>
<h2>Command: dds</h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
dds [-reuse | -noreuse] [-diagram <em>diagram</em>] [-goal <em>goal</em>]  
     [-leader <em>leader</em>] [-trick <em>list of cards</em> [-trick <em>cards</em> ] ...] [ <em>declarer</em> [ <em>denomination</em> ] ]
</pre>

<h3>Summary</h3>
<p>The <code>dds</code> command gives even more refined access to Bo Haglund's double dummy engine, including the ability to solve problems with fewer than 52 cards.

<p>The <code>-reuse</code> flag tells the double-dummy solver to reuse the data it generated from the last call.  For example, if the hand is identical to the previous call and played in the same denomination, you'll want to reuse the data.
<p>The <code>-noreuse</code> flag tells the double-dummy solver not to reuse the data.  This is the default.
<p>The <code>-diagram</code> flag tells the double-dummy solver to solve a specific diagram, rather than the current deal.  A diagram is of the form of a Tcl list in the order north, east, south, west.  
<p>The <code>-leader</code> flag tells the double-dummy solver who is on lead to the current trick.
<p>The <code>-trick</code> flag gives a list of cards played to the current trick.
<p>For example, to solve George Coffin's "Avoidance" end position from his <a href="http://www.rpbridge.net/9p01.htm">Great 88</a>, you would write:
<pre class='example'>
set diagram {
           {A987 - A -} 
           {Q5 987 - -} 
           {64 K2 2 -} 
           {K2 AQ3 - -} 
}
set tricks [dds -leader south -diagram $diagram south notrump]
...
</pre>
<p>If you wanted to see how many tricks are made if south plays a particular card, say the two of clubs, you would use the -trick flag:
<pre class='example'>
set tricks [dds -leader south -diagram $diagram -trick 4S south notrump]
</pre>
You can also pass full tricks, as in:
<pre class='example'>
set tricks [dds -leader west -diagram $diagram -trick {4S KS 7S 5S} south notrump]
</pre>
<p>Note that the -leader option always refers to the leader to the current trick, not the leader of earlier completed tricks passed with -trick. Also, the number of tricks returned is the number of tricks after all completed tricks.
<p>There are example tests of all the Great 88 in the file <code>tests/great88</code> that is included in this release.
</td>
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C, C++</dd>
<dt>Location:</dt>
<dd><code>dds.cpp, tcl_dds.c</code>
</dl>
</div>
</table>
<hr>

<a name="parscore"></a>
<h2>Command: <code>parscore</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
source lib/parscore.tcl
   ...
set result [parscore <em>dealer</em> <em>vul</em>]

set contract [lindex $result 0]
set declarer [lindex $result 1]
set score [lindex $result 2]
set tricks [lindex $result 3]
set auction [lindex $result 4]
</pre>
<h3>Summary</h3>
This computes the double-dummy par result for the current deal.
<p>
The parscore routine returns a list of five values - the contract (in
the same form that is used by the <a href="#score"><code>score</code></a>
routine above), the declarer, the score for north/south, the number of
tricks taken, and a "stupid" auction to the contract suitable for putting
into a PBN file.
<p>
Dealer is relevant on a few occasions.  If both south and west can make
1NT, for example, and no 2-level contracts make, then "par" is 1NT by
whomever gets a chance to bid it first.
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl
<dt>Location:</dt>
<dd><code>parscore.tcl</code>
</dl>
</div>
</table>
<hr>




<a name="gibstuff"></a>
<h1>GIB-related routines</h1>
These next routines use calls to the GIB double-dummy engine.  You must have
a licensed version of <a href="http://www.gibware.com/">GIB</a>
installed on your computer for these routines to work. Also, these
routines only work on Windows at the moment.
<p>
<a name="gib::directory"></a>
<h2>Command: <code>gib::directory</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
source lib/gib.tcl
   ...
gib::directory <em>path</em>
</pre>
<h3>Summary</h3>
This tells the GIB-related routines where GIB is installed.
<p>
If this routine is not called, it defaults to GIB's default install
directory, <span class='nobr'><code>C:/Program Files/GIB</code>.</span>
<p>
<em>Note: your path should include forward slashes '<code>/</code>',
even on Windows.</em> 
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl</dd>
<dt>Location:</dt>
<dd><code>gib.tcl</code>
</dl>
</div>
</table>
<hr>

<a name="gib::tricks"></a>
<h2>Command: <code>gib::tricks</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
source lib/gib.tcl
   ...
gib::tricks <em>declarer</em> <em>denomination</em>
</pre>
<h3>Summary</h3>
<p>You probably want to use the <a href="#deal::tricks"><code>deal::tricks</code></a> command, even when using GIB's double dummy solver.
<p><em>Denomination</em> can be a suit name or "<code>notrump</code>."
<em>Declarer</em> can be any hand name.
<p>
This routine returns the double-dummy number of tricks available
in this deal, in the given denomination by the given declarer.
<p>
If GIB is installed anywhere unusual, you will need to call
<a href="#gib::directory"><code>gib::directory</code></a> before
<code>deal::tricks</code> is called.
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl</dd>
<dt>Location:</dt>
<dd><code>gib.tcl</code>
</dl>
</div>
</table>
<hr>

<h1>Bridge Command Builders</h1>

<p>A number of common types of bridge functions can easily be implemented to
run quickly via lookup tables, including 
<a href="#holdingp">holding</a> and <a href="#shape">shape</a> procedures.
Deal lets the user take advantage of these two sorts of lookup procedures
relatively easily</p>

<a name="defvector"></a>
<h2>Command: <code>defvector</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
defvector <em>vec</em> <em>aceVal</em> [ <em>kingVal</em> ... ]

<em>vec</em> <em>handname</em>

<em>vec</em> <code>hand</code> {<em>text hand</em>}

<em>vec</em> <em>handname</em> <em>suitname</em> [ <em>suitname</em> ... ]

<em>vec</em> <em>handname</em> <em>suitname</em> [ <em>suitname</em> ... ]

<em>vec</em> <code>hand</code> {<em>text hand</em>} <em>suitname</em> ...
</pre>
<h3>Summary</h3>
This defines a <a href="#holdingp">holding procedure</a> which assigns
integer values to the various cards in the hand.  For example
<pre class='example'>
defvector hcp6421 6 4 2 1
</pre>
Defines a holding procedure which counts the ace as worth 6 points, the
king as worth 4, the queen as 2, and the jack as 1.
<p>
Vectors are limited to being integer-valued.  For more complicated
holding procedures, use <a href="#holdingProc"><code>holdingProc</code></a>.</p>
<td style="width: 35%">
<div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C</dd>
<dt>Location:</dt>
<dd><code>vector.c</code></dd>
</dl>
<p>Vectors are slighly faster than their equivalent
<a href="#holdingProc"><code>holdingProc</code></a>.  They are an
old optimization which remain mostly for backwards compatibility.
</div>
</table>
<hr>

<a name="holdingProc"></a>
<h2>Command: <code>holdingProc</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
</pre>
<p>
Temporarily, see the <a href="holding.html">seperate documentation</a>.
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl>
<dt>Implementation: <dd>C
<dt>Location: <dd><code>holdings.c</code>, function <code>IDeal_DefHoldingProc</code>
</dl>
</div>
</table>
<hr>

<a name="shapeclass"></a>
<a name="shapecond"></a>
<a name="shapefunc"></a>
<h2>Commands: <code>shapeclass</code>, <code>shapecond</code>, and <code>shapefunc</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
shapeclass <em>name</em> {... <em>code</em> ...}

shapecond <em>name</em> {<em>expr</em>}

shapefunc <em>name</em> {... <em>code</em> ...}

<em>name</em> [ north | south | east | west ]

<em>name</em> eval <em>s</em> <em>h</em> <em>d</em> <em>c</em>

<em>name</em> shape {<em>s</em> <em>h</em> <em>d</em> <em>c</em>}

</pre>
A shape class (or equivalently, a shape condition) also has the list
subcommand:
<pre class='example'>
<em>name</em> list
</pre>
<h3>Summary</h3>
These commands create new procedures which fit the <a href="#shapes">shape
function</a> interface.
<p>
<code>shapeclass</code> and <code>shapecond</code> define procedures which returns boolean
values. <code>shapefunc</code> can return any type of data.
<code>shapecond</code> is actually an alias:
<pre class='example'>
shapecond <em>name</em> {<em>expr</em>}
</pre>
is the equivalent of:
<pre class='example'>
shapeclass <em>name</em> {
  if {<em>expr</em>} {
    return 1
  } else {
    return 0
}
</pre>
The <em>code</em> or <em>expr</em> is allowed to use the variables
<code>s</code>, <code>h</code>, <code>d</code>, or <code>c</code>.
<p>
More details can be found in the
<a href="advanced.html#shapefunc">Advanced Guide</a>.
<p>
The <code>list</code> subcommand for shape classes returns a list of
shapes that are in the class.
<p>
Why are there two subcommands, "eval" and "shape" which do the
roughly the same things?
<p>
Let's say you have a class named "SemiBalanced" already defined,
which includes 5-card majors.  You want to define a "Balanced"
class which excludes the 5-card majors.  You can do this with
the call:
<pre class='example'>
shapecond Balanced {[SemiBalanced eval $s $h $d $c] && $s<5 && $h<5}
</pre>

On the other hand, if you have a shape - output by the, say, a
call to [north shape] you can evaluate it as:
<pre class='example'>
    SemiBalanced shape [north shape]
</pre>
In fact, this is exactly equivalent to calling 
<pre class='example'>
    SemiBalanced north
</pre>
only slightly slower.
<p>Since these routines cache results in memory and use lookup
tables, you should not use any external state or global variables
inside them.

<td style="width: 35%">
<div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation: <dd>C
<dt>Location: <dd><code>dist.c</code>, functions <code>tcl_shapeclass_define</code>,
<code>tcl_shapecond_define</code>, and <code>tcl_shapefunc_define</code>
</dl>
</div>
</table>
<hr>

<a name="statistics"></a>
<h1>Statistics</h1>
<a name="sdev"></a>
<h2>Command: <code>sdev</code></h2>
<table cellpadding=5 style="width: 100%">
<tr><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
sdev <em>name</em>

<em>name</em> add <em>data</em> [ <em>data</em> ... ]

<em>name</em> count

<em>name</em> average

<em>name</em> sdev

<em>name</em> rms
</pre>
<h3>Summary</h3>

The "sdev" command defines a new Tcl procedure with the given name, which behaves as a 
data collection object.  You can add data points to it, or you can retrieve
the current number of data points, the average of the data points, the
standard deviation of the data points, or the "root mean square" of the
data points.
<p>

</td><td style="width: 35%">
<div class='programmer'><b>For Programmers</b><br>
<dl><dt>Implementation:</dt><dd>C code</dd>
<dt>Location:</dt><dd>stat.c, function <code>tcl_sdev_define</code>.
</dl>
<p>This was implemented in C for efficiency reasons - most real number
computations really need to be done in C if they are going to be done
frequently, and here, the "add" command is called quite often in normal
usage.</p>
</div>
</table>
<hr>

<a name="correlation"></a>
<h2>Command: <code>correlation</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign="top"><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
     correlation <em>name</em>

     <em>name</em> add <em>xval</em> <em>yval</em> [ <em>xval</em> <em>yval</em> ... ]

     <em>name</em> count

     <em>name</em> correlate

     <em>name</em> average [ x | y ]

     <em>name</em> sdev [ x | y ]

     <em>name</em> rms [ x | y ]
</pre>
<h3>Summary</h3>
The <code>correlation</code> declaration defines a routine much like
the <code>sdev</code> command, but each datapoint is a pair of values,
and it computes the linear correlation between the <em>x</em> and <em>y</em>
values.
<p>
You can also get individual data for the <code>x</code> and <code>y</code>
values.
<p>
If there is no data, it returns an error on <code>average</code>,
<code>correlate</code>, <code>sdev</code> and <code>rms</code>.
<p>
If there is only one pair entered, it will throw an error on
<code>sdev</code>.
<p>
</td><td style="width: 35%">
<div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt><dd>C code</dd>
<dt>Location:</dt><dd>stat.c, function <code>tcl_correlation_define</code>.
</dl>
<p>This was implemented in C for efficiency reasons - most real number
computations really need to be done in C if they are going to be done
frequently, and here, the "add" command is called quite often in normal
usage.</p>
</div>
</table>

<h1>Utility Procedures </h1>

<a name="exitflag"></a>
<h2>Command Line: -x flag</h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
   deal -x <em>filename</em> <arg> <arg> ...
</pre>
<p>The '-x' flag tells deal to source the file and then exit.</p>
<p>Before doing so, Deal puts remaining arguments into the variables <code>argc</code> and <code>argv</code>, and sets <code>argv0</code> to the filename of the script.
<p>This is useful if you want to skip the entire deal loop, and process stuff on your own.  For example, the code in <code>tests/great88</code> does not generate any deals, it just solves 88 5-card double-dummy problems.  Before the -x flag, you had to
explicitly call 'exit' from such scripts.</p>
</td>
<td></td>
</table>

<a name="full_deal"></a>
<h2>Command: <code>full_deal</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
   set deal [full_deal]
</pre>
<p>This simple utility command returns the deal as a list of hands in the order of north, east, south, and west.  Suitable for psassing into <a href="#ddscmd"><code>dds</code></a> with the <code>-diagram</code> flag, or remembering a deal after the end of the loop.
</td>
<td></td>
</table>

<a name="seed_deal"></a>
<h2>Command: <code>seed_deal</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
seed_deal <em>number</em>
</pre>
<h3>Command Line: -s</h3>
<pre class='example'>
$ deal -s <em>number</em> ...
</pre>
<h3>Summary</h3>
<p><code>seed_deal</code> is used to seed the random number generator, to make sure that Deal generates the same sequence of
random numbers.
<p>Care has to be taken if you want to make sure that you are generating the same sequence of deals.  For one thing, if you have a <code>main</code> inner loop, you should add the command "finish_deal" to the <code>main</code> section.
<pre class='example'>
main {
   finish_deal
   ...
}
</pre>
<p>That bypasses some optimizations and forces an entire deal to be generated each time through <code>main</code>.
</table>
<a name="deal_deck"></a>
<h2>Command: <code>deal_deck</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deal_deck
</pre>
<h3>Summary</h3>
<code>deal_deck</code> is called at every new deal,
even when all 52 cards are specified (<em>stacked</em>) precisely.
Imagine stacking cards as stacking them in an undealt <em>deck</em>,
but that the cards are only distributed to the hands when
<code>deal_deck</code> is called.
<p>
Most of the time, you won't need to call deal_deck directly, but it is
useful to understand its behavior if you are going to write advanced
procedures like <a href="#deal::input">input formats.</a>
<p>
Stacked cards are permanently stacked until the deck is reset.  In this code:
<pre class='example'>
    stack_hand south {AKQ32 AJ53 K54 2}
    deal_deck
    deal_deck
    puts [south spades]
</pre>
The output is "AKQ32".  Use <a href="#reset_deck"><code>reset_deck</code></a>
to undo card stackings.
<p>
The <code>deal_deck</code> procedure does one thing rather complicated
when it is called, the first thing it does is execute  all
code registered with the 
<a href="#deal_reset_cmd"><code>deal_reset_cmds</code></a>.
This allows the script writer to do one of several things before
the deal is generated:
<ul>
<li>Delete metadata related to the deal.  For example, the first time
the user calls <code>deal::tricks south spades</code> it calls the 
double-dummy processor.  Each time after that, it uses a stored
value for this function call up until the next call to
<code>deal_deck</code>.
<li>The reset command might, instead, read the next deal from a file,
stack the deck, and then re-register itself.  Then when deal_deck is
is called, it just deals that hand from the file.  This is a crude
way of allowing Deal to transparently read deals from a file (or generate
deals in other ways, such as <a href="#smartstack">smart stacking.</a>
</ul>
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C
<dt>Location:</dt>
<dd><code>tcl_deal.c</code>, function <code>tcl_deal_deck</code>
</dl>
</div>
</table>
<hr>

<a name="reset_deck"></a>
<h2>Command: <code>reset_deck</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
reset_deck
</pre>
<h3>Summary</h3>
This forgets about all stacked cards.  The <em>deck</em>, from <em>Deal</em>'s
point of view, plus a list of cards which must go to specific hands.
The cards which are assigned to specific hands are "stacked."  The cards
which are not stacked can go anywhere at the next call to
<a href="#deal_deck">deal_deck</a>.
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C
<dt>Location:</dt>
<dd><code>tcl_deal.c</code>, function <code>tcl_reset_deck</code>
</dl>
</div>
</table>
<hr>

<a name="stack_hand"></a>
<a name="stack_cards"></a>
<h2>Commands: <code>stack_hand</code> and <code>stack_cards</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
stack_hand <em>handname</em> <em>hand</em>
stack_cards <em>handname</em> <em>suitname</em> <em>holding</em> [...]
</pre>
<h3>Summary</h3>
By default, these two routines just call <a href="#deck_stack_hand">
deck_stack_hand and deck_stack_cards,</a>
respectively - that is, they forcibly place cards in the deck.
<p>
But these routines are meant to be overridden.  For example, when using
one of the <em>input formats</em> which reads deals from a file,
the format will redefine these two procedures to give errors.
<pre class='example'>
% deal -I "line foo.txt" -e "stack_cards south spades AJ"
Tcl stack dump of error info:
No card stacking with input format ::line
<em>...</em>
</pre>
A more complicated re-definition occurs in the <a name="#smartstack">
<code>smartstack</code> input format,</a> which alters its hand
generation depending on what cards are stacked where.

<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl>
<dt>Implementation:</dt>
<dd>C</dd>
<dt>Location:</dt>
<dd><code>hand.c</code>, function <code>tcl_stack_hand</code> and
<code>tcl_stack_cards</code>
</dl>
</div>
</table>
<hr>

<a name="deck_stack_hand"></a>
<a name="deck_stack_cards"></a>
<h2>Commands: <code>deck_stack_hand</code> and <code>deck_stack_cards</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deck_stack_hand <em>handname</em> <em>hand</em>
deck_stack_cards <em>handname</em> <em>suitname</em> <em>holding</em> [...]
</pre>
<h3>Summary</h3>
These routines are the "underlying" deck-stacking routines.  Any cards
stacked with these routines remain stacked until the next call to
<a href="#reset_deck"><code>reset_deck</code></a>
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl>
<dt>Implementation:</dt>
<dd>C</dd>
<dt>Location:</dt>
<dd><code>hand.c</code>, function <code>tcl_stack_hand</code> and
<code>tcl_stack_cards</code>
</dl>
</div>
</table>
<hr>

<a name="stacked"></a>
<h2>Command: <code>stacked</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
stacked <em>handname</em>
</pre>
<h3>Summary</h3>
Determines what cards are stacked to this hand, returning them as
a list of holdings:
<pre class='example'>
south gets AS KH 3H QD JD TC 9C 8C
puts [stacked south]
</pre>
writes out the list:
<pre class='example'>
A K3 QJ T98
</pre>
This is useful for the <a href="#smartstack">smartstacker</a>, because
we don't want to force the user to stack cards *after* specifying conditions.
<pre class='example'>
stack_hand north {AJT KT3 KJ 75432}
deal::input smartstack south balanced hcp 20 21
</pre>
The call to <code>stack_hand</code> occurs before <code>smartstack</code>
is loaded, so <code>stack_hand</code> has not been redefined.  So what
<code>smartstack</code> does is read the cards already stacked, and
use that for its initial conditions.
<p>
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C</dd>
<dt>Location:</dt>
<dd><code>tcl_deal.c</code>, function <code>tcl_stacked_cards</code>
</dl>
</div>
</table>
<hr>

<a name="deal::nostacking"></a>
<h2>Command: <code>deal::nostacking</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
::deal::nostacking
</pre>
<h3>Summary</h3>
This procedure redefines the <a href="#stack_hand">stack_hand and
stack_cards</a> procedures to generate error messages, and
generates an error if any cards are currently stacked.
<p>
This is used in all of the input formats which read complete deals from
files, and thus are incompatible with stacking.
<td style="width: 35%"><div class='programmer'>
<b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl code</dd>
<dt>Location:</dt>
<dd><code>lib/features.tcl</code>, function <code>deal::nostacking</code>
</dl>
</div>
</table>
<hr>


<a name="deal_reset_cmds"></a>
<h2>Command: <code>deal_reset_cmds</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deal_reset_cmds {<em>...code...</em>} [ ... ]
</pre>
<h3>Summary</h3>
This adds a set of commands that are to be called before the next
deal.  The code is executed at the next call to the
<a href="#deal_deck"><code>deal_deck</code></a> procedure, which, unless
you are doing something complicated, means it is called at the beginning
of each time through the evaluation loop.
<p>
<code>deal_reset_cmds</code> can be used so that metadata about the previous deal,
such as cached values and the like, are unset.  See
<a href="#deal::metadata"><code>deal::metadata</code></a>.
<p>
It is also used for defining <a href="#deal::input">input formats,</a>
so that deals can be read from files.  For example, the "line" input format
has the following routine declared:
<pre class='example'>
namespace eval line {
    #....
    proc next {} {
	variable handle
	set length -1
	catch { set length [gets $handle line] }

        # ... process the line, or handle oef stuff ...
        # ...
	deal_reset_cmds {::line::next}
    }
}
</pre>
<p>
The key is that when <code>line::next</code> is done, it re-registers itself, making
sure that it is called next time through as well.
<p>
The <em>code</em> passed in to <code>deal_reset_cmds</code> is
called only once, at the next request for a deal - think of it as
registering a one-time trigger.  Multiple triggers can be registered -
they are called in the reverse order that they are added, which can seem
counter-intuitive until you think of the process as an "undo" process.
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>C</dd>
<dt>Location:</dt>
<dd><code>tcl_deal.c</code>, function <code>add_reset_cmds</code>
</dl>
</div>
</table>
<hr>

<a name="deal::metadata"></a>
<h2>Command: <code>deal::metadata</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deal::metadata <em>name</em> {<em>...code...</em>}
</pre>
<h3>Summary</h3>
Currently, this is just a peculiar way of caching slow evaluation routines.
At the moment, the only place it is used is in
<a href="#deal::tricks"><code>deal::tricks</code></a>.
<p>
When you call <code>deal::metadata</code>, it will check to see if
there is a value associated with the <em>name</em> requested 
already.  If there is, the value is returned.  If it does not, it evaluates the
specified code and associates the result with the <em>name</em>.  The key
is, when the next deal is being analyzed, all the cached values are pitched.
<p>
This isn't really necessary or efficient in most cases, but with
evaluations which take some time, <em>e.g.</em> GIB calls, it
improves things.
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd><code>Tcl</code>
<dt>Location:</dt>
<dd><code>lib/features.tcl</code>
</dl>
<p>In later releases, metadata read from input streams (say, the fields
from a PBN file) will also be stored here.
<p>
This procedure uses
<a href="#deal_reset_cmds"><code>deal_reset_cmds</code></a>.
The metadata is cleared each time the <code>deal_deck</code>
command is called.
</div>
</table>
<hr>

<h1>Input formats</h1>
<a name="deal::input"></a>
<h2>Command: <code>deal::input</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deal::input <em>formatName</em> <em>args</em>
</pre>
<h3>Summary</h3>
The <code>deal::input</code> command is used to define an input source
for deals. It works as follows:
<ol>
<li>The file <code>input/&lt;formatName&gt;.tcl</code> is loaded.  This
Tcl file should define a new Tcl 'namespace' with the name <em>formatName</em>,
with member procedures named <code>set_input</code> and <code>next</code>.
<li>Deal then calls 
<code>&lt;formatName&gt;::set_input <em>args</em></code>, which should
initialize the format reading.  Usually, the argument(s) are one argument
representing the source file.
<li>The next deal, <code>&lt;formatName&gt;::next</code> is called.
</ol>
</td>
<td style="width: 35%">
<div class='programmer'><b>For Programmers</b>
<dl>
<dt>Implementation:</dt>
    <dd>Tcl code</dd>
<dt>Location:</dt>
    <dd>lib/features.tcl</dd>
</dl>
</div></table>
<hr>
<a name="giblib"></a><a name="library.dat"></a>
<h2>Input Format: <code>giblib</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deal::input giblib [<em>filename</em>]
</pre>
or on the command line:
<pre class='example'>
% deal -I giblib
</pre>
or
<pre class='example'>
% deal -I "giblib <em>filename</em>"
</pre>
<h3>Summary</h3>
<p>Specifies that deals are read from the specified file in the format
of Matt Ginsberg's library.dat file.  This includes double-dummy tricks
data, so that later calls to <a href="#deal::tricks"><code>deal::tricks</code></a>
will not entail calls to the GIB binaries.</p>
<p>
If no filename is given, the library tries to read from a file called
"library.dat" in the current directory.
<p>
The <code>-I</code> command-line flag is a quick alias for
<code>deal::input</code>, passing the next argument as
Tcl arguments to the <code>deal::input</code> command.
<td style="width: 35%">
<div class='programmer'><b>For Programmers</b>
<dl>
<dt>Implementation:</dt>
    <dd>Tcl code</dd>
<dt>Location:</dt>
    <dd>input/giblib.tcl</dd>
</dl>
<p>This procedure uses <a href="#deal_reset_cmds">deal_reset_cmds</a>.</p>
</div>
</table>
<hr>

<a name="line"></a>
<h2>Input Format: <code>line</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deal::input line [<em>filename</em>]
</pre>
<h3>Summary</h3>
<p>Specifies that deals are read from the specified file in the format
written by Deal's "-l" option.
<p>
If no filename is given, the library reads from standard
input.  This way, you can create a single data file and then
run several different queries against it:
<pre class='example'>
% deal -l 100000 > sample
% deal -e "deal::input line sample" -i query1
% deal -e "deal::input line sample" -i query2
</pre>
[ The <code>-e</code> option just evaluates the code in the next
argument as Tcl code.  Alternative, you can use the <code>-I</code>
option, which is shorthand for input formats:
<pre class='example'>
% deal -I "line sample" -i query1
</pre>
The <code>-I <em>args</em></code> option is exactly the same as -e "deal::input <em>args</em>".]

<td style="width: 35%">
<div class='programmer'><b>For Programmers</b>
<dl>
<dt>Implementation:</dt>
    <dd>Tcl code</dd>
<dt>Location:</dt>
    <dd>input/line.tcl</dd>
</dl>
</div>
</table>
<a name="ddline"></a>
<h2>Input Format: <code>ddline</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deal::input line [<em>filename</em>]
</pre>
<h3>Summary</h3>
<p>Specifies that deals are read from the specified file in the format
written by Deal's <a href="#format:ddline"><code>ddline</code> format.</a>
<p>The ddline format include doubled-dummy tricks data, so when using <code>ddline</code> for input, calls to <a href="deal::tricks">deal::tricks</a> return the data read from the file.
<td style="width: 35%">
<div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
    <dd>Tcl code</dd>
<dt>Location:</dt>
    <dd>input/line.tcl</dd>
</dl>
</div>
</table>
<a name="smartstack"></a>
<h2>Input: <code>smartstack</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
deal::input smartstack <em>hand</em> <em>shapeclass</em> [<em>holdproc</em> <em>min</em> <em>max</em>]
</pre>
or on the command line:
<pre class='example'>
% deal -I "smartstack <em>shapeclass</em> ..."
</pre>
<h3>Summary</h3>
This is the most complicated Deal input method in the current release.
It does not read deals from a file - it is, instead, a different path to
generation of deals.  The purpose of this format is to allow fast generations
of deals where one hand fits a very specific description.  For example,
if you want to find hands where south has a balanced 27-count, you
could write:
<pre class='example'>
deal::input smartstack south balanced hcp 27 27
</pre>
On my computer, that returns the first deal in 14 seconds, and every deal after
that takes a tiny fraction of a second.  That's because <code>smartstack</code>
first builds a large "factory" in memory, but once it is built, the
factory spits out hands matching this condition very quickly.
<p>
By contrast, a standard "deal" script to find balanced 27-counts
takes about 2.8 seconds to find each deal.  That means that if you only
want to find about five deals of this sort, the old style program
is faster, but if you want a lot more, use <code>smartstack</code>.
For example, if you wanted 1000 examples, <code>smartstack</code>
takes about 15 seconds, while the old deal will take about 45 minutes.
<p>
One interesting feature of <code>smartstack</code> is that it is often
faster if the hand type is less frequent.  For example, it takes about 6
seconds to find ten deals with 9-card spade suits, and about 5 seconds to
find ten deals with 10-card spade suits.  Similarly, it is faster at
finding hands with exactly 9 controls than it is at finding hands
with 9-12 controls.
<p>
The <code>smartstack</code> routine only works on one hand - after it
places cards in that hand, it generates the rest using the usual
algorithm.
<td style="width: 35%">
<div class='programmer'><b>For Programmers</b>
<dl>
<dt>Implementation:</dt>
    <dd>Tcl code</dd>
<dt>Location:</dt>
    <dd>input/smartstack.tcl, lib/handFactory.tcl</dd>
<dt>Notes</dt>
<dd>See the two articles from the bridge developers mailing list
describing the algorithm:
<a href="http://www.cirl.uoregon.edu/pipermail/developers/2001-February/000339.html">My first stab at describing it</a> and
<a href="http://www.cirl.uoregon.edu/pipermail/developers/2001-February/000342.html">some corrections.</a>

</dl>
</div>
</table>
<hr>
<h1>Formatting</h1>
<a name="write_deal"></a>
<h2>Command: <code>write_deal</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
write_deal
</pre>
<h3>Summary</h3>
This is the the name of a procedure which is called when deals are accepted.
By default, it writes the result in the format:
<pre class='example'>
          S: 98632
          H: A4
          D: AJ754
          C: J
 S: K              S: AJT7
 H: J3             H: QT95
 D: T98            D: Q2
 C: AKT7532        C: 984
          S: Q54
          H: K8762
          D: K63
          C: Q6
--------------------------
</pre>
New output formats are defined by <em>redefining this routine</em>.
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl
<dt>Location:</dt>
<dd><code>format/default</code>
</dl>
</div>
</table>
<hr>
<a name="flush_deal"></a>
<h2>Command: <code>flush_deal</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
flush_deal
</pre>
<h3>Summary</h3>
This routine is called at the very end of a run for deal. It does nothing,
by default, but some output formats may require it if data is cached.
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl>
<dt>Implementation:</dt>
<dd>Tcl code</dd>
<dt>Location:</dt>
<dd><code>format/default</code>, function <code>flush_deal</code>
</dl>
</div>
</table>
<hr>

<a name="format:par"></a>
<h2>Output Format: <code>format/par</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
source format/par
</pre>
<h3>Summary</h3>
<p>By including this file, you are setting the output format to write the results in PBN format, with results set to the double dummy theoretical par.
<pre class='example'>
$ deal -i format/par 1
[Date "2008.05.19"]
[Board "1"]
[West "West"]
[North "North"]
[East "East"]
[South "South"]
[Dealer "N"]
[Vulnerable "None"]
[Deal "N:K.A7.QJT9865.AK7 T94.K98532.2.943 A872.QT4.AK4.862 QJ653.J6.73.QJT5"]
[Contract "6N"]
[Declarer "S"]
[Result "12"]
[Score "NS 990"]
{
          S: K
          H: A7
          D: QJT9865
          C: AK7
 S: QJ653          S: T94
 H: J6             H: K98532
 D: 73             D: 2
 C: QJT5           C: 943
          S: A872
          H: QT4
          D: AK4
          C: 862
north makes 9 tricks in clubs
north makes 12 tricks in diamonds
north makes 8 tricks in hearts
north makes 7 tricks in spades
north makes 12 tricks in notrump
east makes 3 tricks in clubs
east makes 1 tricks in diamonds
east makes 5 tricks in hearts
east makes 4 tricks in spades
east makes 1 tricks in notrump
south makes 8 tricks in clubs
south makes 12 tricks in diamonds
south makes 8 tricks in hearts
south makes 7 tricks in spades
south makes 12 tricks in notrump
west makes 3 tricks in clubs
west makes 1 tricks in diamonds
west makes 5 tricks in hearts
west makes 4 tricks in spades
west makes 1 tricks in notrump
}
[Auction "N"]
Pass   Pass   6N
[Play "W"]
*
</pre>
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl</dd>
<dt>Location:</dt>
<dd><code>format/par</code></dd>
</dl>
</div>
</table>
<hr>

<a name="format:ddline"></a>
<h2>Output Format: <code>format/ddline</code></h2>
<table cellpadding=5 style="width: 100%">
<tr valign=top><td style="width: 65%">
<h3>Usage</h3>
<pre class='example'>
source format/ddline
</pre>
<h3>Summary</h3>
<p>By including this file, you are redefining the output format to the form "ddline", which writes out the deal on a single line, as with the '-l' flag, but then adds complete double-dummy data to the deal as well.  If you write the output to a file:
<pre class='example'>
$ deal -i format/ddline 100 > doubledummy.txt
</pre>
<p>then you can use the <a href="#ddline"><code>ddline</code> input format</a> to read the file back in:
<pre class='example'>
$ deal -I "ddline doubledummy.txt" -i query.tcl 100
</pre>
<p>And any call to <code>deal::tricks</code> in query.tcl will use the value stored doubledummy.txt.
<td style="width: 35%"><div class='programmer'><b>For Programmers</b>
<dl><dt>Implementation:</dt>
<dd>Tcl</dd>
<dt>Location:</dt>
<dd><code>format/ddline</code></dd>
</dl>
</div>
</table>

